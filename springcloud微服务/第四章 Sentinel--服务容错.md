# **第四章** **Sentinel--服务容错**

## **4.1** **高并发带来的问题** 

在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以相互调用，但是由于网络 

原因或者自身的原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会 

出现网络延迟，此时若有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪

![1625726112216](1625726112216.png)



**接下来，我们来模拟一个高并发的场景**

**1 编写java代码**

```java
//在订单服务的下订单接口中模拟一次网络延时 
try {
    Thread.sleep(1000);
} catch (InterruptedException e) { 
    e.printStackTrace(); 
}
```

**2 修改配置文件中tomcat的并发数**

```yml
server: 
	port: 8091 
	tomcat: 
		max-threads: 10 #tomcat的最大并发值修改为10,默认是200
```

**3 接下来使用压测工具,对请求进行压力测试**

下载地址https://jmeter.apache.org/

- 第一步：修改配置，并启动软件 

  进入bin目录,修改jmeter.properties文件中的语言支持为language=zh_CN，然后点击jmeter.bat 

  启动软件。

![1625725492141](1625725492141.png)

- 第二步：添加线程组

![1625725531090](1625725531090.png)

- 第三步：配置线程并发数

![1625725584611](1625725584611.png)

- 第四步：添加Http取样

![1625725603635](1625725603635.png)

- 第五步：配置取样，并启动测试

![1625725621486](1625725621486.png)

![1625737172165](1625737172165.png)

**4 访问ｍessage方法观察效果**

**结论**:

此时会发现, 由于order方法囤积了大量请求, 导致ｍessage方法的访问出现了问题，这就是**服务雪崩**的雏形。

## **4.2** **服务雪崩效应**

在分布式系统中,由于网络原因或自身的原因,服务一般无法保证 100% 可用。如果一个服务出现了 问题，调用这个服务就会出现线程阻塞的情况，此时若有大量的请求涌入，就会出现多条线程阻塞等 待，进而导致服务瘫痪。 

由于服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是 

服务故障的 **“雪崩效应”** 。

![1626059421778](1626059421778.png)

雪崩发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某 

台机器的资源耗尽。我们无法完全杜绝雪崩源头的发生，只有做好足够的容错，保证在一个服务发生问 

题，不会影响到其它服务的正常运行。也就是＂雪落而不雪崩＂。

## **4.3** **常见容错方案**

要防止雪崩的扩散，我们就要做好服务的容错，容错说白了就是保护自己不被猪队友拖垮的一些措 

施, 下面介绍常见的服务容错思路和组件

**常见的容错思路** 

常见的容错思路有隔离、超时、限流、熔断、降级这几种，下面分别介绍一下

- **隔离** 

  它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故 

  障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的 

  系统服务。常见的隔离方式有：线程池隔离和信号量隔离

![1626059520453](1626059520453.png)

- **超时** 

  在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作出反应， 

  就断开请求，释放掉线程

![1626059678408](1626059678408.png)

- **限流** 

  限流就是限制系统的输入和输出流量已达到保护系统的目的。为了保证系统的稳固运行,一旦达到 

  的需要限制的阈值,就需要限制流量并采取少量措施以完成限制流量的目的

![1626059693018](1626059693018.png)

- **熔断**

   在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整 

  体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。

![1626059710048](1626059710048.png)

服务熔断一般有三种状态： 

1. 熔断关闭状态（Closed） 

   服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制 

2. 熔断开启状态（Open） 

   后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法 

3. 半熔断状态（Half-Open） 

   尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预 

   期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状 

   态。

   

- **降级** 

  降级其实就是为服务提供一个托底方案，一旦服务无法正常调用，就使用托底方案。

![1626059870246](1626059870246.png)

**常见的容错组件** 

- **Hystrix** 

  Hystrix是由Netflflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止 

  级联失败，从而提升系统的可用性与容错性。 

- **Resilience4J** 

  Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推 

  荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和 

  prometheus等多款主流产品进行整合。 

- **Sentinel** 

  Sentinel 是阿里巴巴开源的一款断路器实现，本身在阿里内部已经被大规模采用，非常稳定



## 4.4 Sentinel入门

### **4.4.1** **什么是**Sentinel

Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于**服务容错**的综合性解决方案。它以流量 

为切入点, 从**流量控制、熔断降级、系统负载保护**等多个维度来保护服务的稳定性。

**Sentinel** **具有以下特征**:

- **丰富的应用场景**：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景, 例如秒杀（即 

  突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用 

  应用等。 

- **完备的实时监控**：Sentinel 提供了实时的监控功能。通过控制台可以看到接入应用的单台机器秒 

  级数据, 甚至 500 台以下规模的集群的汇总运行情况。 

- **广泛的开源生态**：Sentinel 提供开箱即用的与其它开源框架/库的整合模块, 例如与 Spring 

  Cloud、Dubbo、gRPC 的整合。只需要引入相应的依赖并进行简单的配置即可快速地接入 

  Sentinel。

- **完善的** **SPI** **扩展点**：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快 

  速地定制逻辑。例如定制规则管理、适配动态数据源等。

**Sentinel** **分为两个部分**: 

- 核心库（Java 客户端）不依赖任何框架/库,能够运行于所有 Java 运行时环境，同时对 Dubbo / 

  Spring Cloud 等框架也有较好的支持。 

- 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等 

  应用容器。

### **4.4.2** **微服务集成**Sentinel

为微服务集成Sentinel非常简单, 只需要加入Sentinel的依赖即可(在订单服务添加)

1 在pom.xml中加入下面依赖

```xml
<dependency> 
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId> 
</dependency>
```

2 编写一个Controller测试使用

```java
@RequestMapping("/order/message1") 
public String message1() { 
    return "message1"; 
}

@RequestMapping("/order/message2") 
public String message2() { 
    return "message2";
}
```

### **4.4.3** **安装**Sentinel控制台

Sentinel 提供一个轻量级的控制台, 它提供机器发现、单机资源实时监控以及规则管理等功能。

1 下载jar包,解压到文件夹 

https://github.com/alibaba/Sentinel/releases

2 启动控制台

```yml
# 直接使用jar命令启动项目(控制台本身是一个SpringBoot项目) 
java -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080           -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.7.0.jar

#-Dserver.port端口
#-Dcsp.sentinel.dashboard.server项目访问路径
#-Dproject.name 项目名
```

3 修改 shop-order ,在里面加入有关控制台的配置

```yml
spring:
	cloud: 
		sentinel: 
			transport: 
				port: 9999 #跟控制台交流的端口,随意指定一个未使用的端口即可 
				dashboard: localhost:8080 # 指定控制台服务的地址
```

第4步: 通过浏览器访问localhost:8080 进入控制台 ( 默认用户名密码是 sentinel/sentinel )

![1626061367961](1626061367961.png)

**补充：了解控制台的使用原理** 

Sentinel的控制台其实就是一个SpringBoot编写的程序。我们需要将我们的微服务程序注册到控制台上, 

即在微服务中指定控制台的地址, 并且还要开启一个跟控制台传递数据的端口, 控制台也可以通过此端口 

调用微服务中的监控程序获取微服务的各种信息

### **4.4.4** **实现一个接口的限流**

1 通过控制台为message1添加一个流控规则

![1626061621239](1626061621239.png)

![1626061709226](1626061709226.png)

2 通过控制台快速频繁访问, 观察效果

![1626061831496](1626061831496.png)

## **4.5 Sentinel**的概念和功能

### **4.5.1** **基本概念**

- **资源** 

  **资源就是Sentinel要保护的东西** 

  资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，可以是一个服务，也可以是 

  一个方法，甚至可以是一段代码

> 我们入门案例中的message1方法就可以认为是一个资源

- **规则** 

  **规则就是用来定义如何进行保护资源的** 

  作用在资源之上, 定义以什么样的方式保护资源，主要包括流量控制规则、熔断降级规则以及系统 

  保护规则。 

> 我们入门案例中就是为message1资源设置了一种流控规则, 限制了进入message1的流量

### **4.5.2** **重要功能**

![1626078580452](1626078580452.png)

- **流量控制** 

  流量控制在网络传输中是一个常用的概念，它用于调整网络包的数据。任意时间到来的请求往往是 

  随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。 

  Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状

- **熔断降级**

  当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则 

  对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。

**总之一句话:我们需要做的事情，就是在Sentinel的资源上配置各种各样的规则，来实现各种容错的功能**



## **4.6 Sentinel**规则

### **4.6.1** **流控规则**

​	流量控制，其原理是监控应用流量的QPS(每秒查询率) 或并发线程数等指标，当达到指定的阈值时 

对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。 

第1步: 点击簇点链路，我们就可以看到访问过的接口地址，然后点击对应的流控按钮，进入流控规则配 

置页面。新增流控规则界面如下

![1626078789086](1626078789086.png)

**资源名**：唯一名称，默认是请求路径，可自定义 

**针对来源**：指定对哪个微服务进行限流，默认指default，意思是不区分来源，全部限制 

**阈值类型/单机阈值**： 

- QPS（一个线程每秒请求数量）: 当调用该接口的QPS达到阈值的时候，进行限流 
- 线程数：当调用该接口的**线程数**达到阈值的时候，进行限流 

**是否集群**：暂不需要集群 



测试QPS设置2，表示每秒请求阈值2次

![1626079077679](1626079077679.png)

测试线程数，设置为2表示最多2个线程访问

![1626079295458](1626079295458.png)

![1626079275747](1626079275747.png)

## ![1626079388292](1626079388292.png)

## 4.7 Feign整合Sentinel

第1步: 引入sentinel的依赖

```xml
<!--sentinel客户端--> 
<dependency> 
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId> 
</dependency>
```

第2步: 在配置文件中开启Feign对Sentinel的支持

```yml
feign: 
	sentinel:
    	enabled: true
```

第3步: 创建容错类

```java
//容错类要求必须实现被容错的接口,并为每个方法实现容错方案
@Component 
@Slf4j 
public class ProductServiceFallBack implements ProductService { 
    @Override 
    public Product findByPid(Integer pid) { 
        Product product = new Product(); 
        product.setPid(-1); 
        return product;
    } 
}
```

第4步: 为被容器的接口指定容错类

```java
//value用于指定调用nacos下哪个微服务 
//fallback用于指定容错类 
@FeignClient(value = "service-product", fallback = ProductServiceFallBack.class) public interface ProductService { 
    @RequestMapping("/product/{pid}")//指定请求的URI部分 
    Product findByPid(@PathVariable Integer pid);
}
```

第5步: 修改controller

第6步: **停止所有 shop-product 服务**,重启 shop-order 服务,访问请求,观察容错效果

![1626081982435](1626081982435.png)